#!/usr/bin/env python3

# example era secrets header
"""
#ifndef SECRETS_H
#define SECRETS_H
#define NUM_CHANNELS 5

uint32_t channels_numbers[NUM_CHANNELS] = {
0,
1,
2,
3,
4,
};

uint8_t channels_keys[][33] = {
    { 0x37, 0x39, 0x37, 0x38, 0x36, 0x62, 0x39, 0x63, 0x33, 0x66, 0x63, 0x33, 0x38, 0x31, 0x33, 0x31, 0x64, 0x63, 0x61, 0x63, 0x61, 0x61, 0x34, 0x64, 0x61, 0x38, 0x65, 0x64, 0x39, 0x34, 0x30, 0x61, 0x00 }, // Channel 0
    { 0x38, 0x30, 0x30, 0x34, 0x38, 0x65, 0x66, 0x61, 0x64, 0x65, 0x65, 0x35, 0x38, 0x34, 0x33, 0x62, 0x37, 0x34, 0x33, 0x38, 0x39, 0x36, 0x35, 0x30, 0x39, 0x35, 0x61, 0x33, 0x38, 0x31, 0x35, 0x37, 0x00 }, // Channel 1
    { 0x34, 0x63, 0x62, 0x37, 0x35, 0x37, 0x30, 0x34, 0x35, 0x31, 0x32, 0x63, 0x36, 0x66, 0x36, 0x65, 0x62, 0x34, 0x30, 0x39, 0x66, 0x34, 0x37, 0x65, 0x30, 0x30, 0x62, 0x64, 0x30, 0x39, 0x63, 0x31, 0x00 }, // Channel 2
    { 0x62, 0x36, 0x32, 0x39, 0x38, 0x34, 0x35, 0x61, 0x62, 0x32, 0x30, 0x66, 0x37, 0x64, 0x62, 0x65, 0x39, 0x37, 0x31, 0x39, 0x30, 0x62, 0x66, 0x34, 0x66, 0x39, 0x66, 0x39, 0x61, 0x31, 0x39, 0x37, 0x00 }, // Channel 3
    { 0x37, 0x33, 0x33, 0x36, 0x39, 0x37, 0x65, 0x65, 0x39, 0x33, 0x62, 0x32, 0x31, 0x64, 0x63, 0x64, 0x34, 0x37, 0x65, 0x32, 0x35, 0x32, 0x33, 0x64, 0x30, 0x36, 0x66, 0x62, 0x63, 0x34, 0x32, 0x32, 0x00 }, // Channel 4
};

uint8_t ENCODERS_SALT[] = { 0x32, 0x38, 0x64, 0x61, 0x35, 0x62, 0x61, 0x38, 0x64, 0x38, 0x39, 0x61, 0x32, 0x34, 0x65, 0x38, 0x00 };
uint8_t DECODERS_SALT[] = { 0x37, 0x37, 0x66, 0x63, 0x63, 0x38, 0x39, 0x64, 0x31, 0x61, 0x32, 0x63, 0x32, 0x66, 0x30, 0x37, 0x00 };
uint8_t ENCODER_KEY[] = { 0x64, 0x38, 0x35, 0x65, 0x64, 0x63, 0x65, 0x36, 0x31, 0x33, 0x38, 0x31, 0x34, 0x32, 0x35, 0x65, 0x35, 0x35, 0x61, 0x35, 0x62, 0x65, 0x38, 0x63, 0x37, 0x64, 0x34, 0x34, 0x31, 0x32, 0x30, 0x32 };
uint8_t SUB_KEY[] = { 0x61, 0x33, 0x62, 0x33, 0x62, 0x38, 0x34, 0x37, 0x65, 0x38, 0x65, 0x65, 0x38, 0x31, 0x32, 0x63, 0x38, 0x62, 0x32, 0x62, 0x35, 0x33, 0x32, 0x62, 0x38, 0x31, 0x65, 0x36, 0x37, 0x36, 0x64, 0x35 };

#endif // SECRETS_H
"""

from pwn import *
from decoder import DecoderIntf

context.arch = 'arm'

def conn():
    r = DecoderIntf('/dev/ttyACM0')

    return r


REAL_ENCODER_KEY = 'bb1d5f9dde42ab5261eb6c49ae17542c'
REAL_ENCODER_SALT = '1fe6f644ab65f9bf'
# not 100% on this
REAL_CHANNEL0_KEY = '21c65d54f0fa9920bf3826c64ed18200'

import argparse
import struct
import json
import base64
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from hashlib import sha256

class Encoder:
    def __init__(self):
        """
        You **may not** change the arguments or returns of this function!

        :param secrets: Contents of the secrets file generated by
        ectf25_design.gen_secrets
        """

        self.encoder_key = REAL_ENCODER_KEY
        self.encoder_salt = REAL_ENCODER_SALT

    def get_channel_key(self, channel):
        if channel == 0:
            return REAL_CHANNEL0_KEY
        else:
            return None

    def encode(self, channel: int, frame: bytes, timestamp: int) -> bytes:
        """The frame encoder function

        This will be called for every frame that needs to be encoded before being
        transmitted by the satellite to all listening TVs

        You **may not** change the arguments or returns of this function!

        :param channel: 32b unsigned channel number. Channel 0 is the emergency
        broadcast that must be decodable by all channels.
        :param frame: Frame to encode. Max frame size is 64 bytes.
        :param timestamp: 64b timestamp to use for encoding. **NOTE**: This value may
        have no relation to the current timestamp, so you should not compare it
        against the current time. The timestamp is guaranteed to strictly
        monotonically increase (always go up) with subsequent calls to encode

        :returns: The encoded frame, which will be sent to the Decoder
        """
        # declare useful local variables
        timestamp_bytes = struct.pack("<Q", timestamp)
        channel_bytes = struct.pack("<I", channel)

        #size of the plain frame
        frame_size = len(frame)

        # Generate the encryption key
        if self.get_channel_key(channel) is None:
            print('dummy frame')
            key = '0' * 32
        else:
            key = sha256(self.get_channel_key(channel).encode() + str(timestamp).encode() + self.encoder_salt.encode()).hexdigest()[:32]

        # encrypt the frame
        frame = pad(frame, 16)
        cipher = AES.new(key.encode('utf-8'), AES.MODE_ECB)
        in64 = base64.b64encode(cipher.encrypt(frame))

        # generate the integrity hash
        data = channel_bytes + timestamp_bytes + base64.b64decode(in64) + self.encoder_salt.encode()
        integrity_hash = sha256(data).hexdigest()


        # encrypting the whole payload
        payload = pad(struct.pack("<IQ", channel, timestamp) + bytes.fromhex(integrity_hash) + base64.b64decode(in64), 16)
        payload_cipher = AES.new(self.encoder_key.encode('utf-8'), AES.MODE_ECB)
        encrypted_payload = base64.b64encode(payload_cipher.encrypt(payload))

        # size of the plain payload
        size = len(struct.pack("<IQ", channel, timestamp) + bytes.fromhex(integrity_hash) + base64.b64decode(in64))

        # returning the encrypted payload + the size of the plain payload
        return struct.pack("<Q", int(size)) + struct.pack("<I", int(frame_size)) + base64.b64decode(encrypted_payload)


def altered_len(packet, length):
    return packet[0:8] + p32(length) + packet[12:]

def leak(r, packet):

    # packet = b"<\x00\x00\x00\x00\x00\x00\x00\x07\x00\x00\x00f\x9d\xe3\x97\x16\xab>\r\\\x89\x1f\xc1N\xef\x1dvdP\x152A\xbf'\xa2\x1d\x14\xd2\xe6\x9bQt]\xc0\n\xb6&\xb0 c\xef\xda(\x8b\xb6\xbd\x81\xe4\xe6H\xecf\x04\xc4\xb0\x97\xee\x8d\x8c\xad\x85\xc9\xa7\x1c<"
    # packet_len = 7

    leak = r.decode(altered_len(packet, 0x700))
    print(leak)

    channel_key_offset = 152
    encoder_salt_offset = 186
    encoder_key_offset = 1288

    channel_key = leak[channel_key_offset:channel_key_offset + 0x20]
    encoder_salt = leak[encoder_salt_offset:encoder_salt_offset + 0x10]
    encoder_key = leak[encoder_key_offset:encoder_key_offset + 0x20]

    print(f'{channel_key = }')
    print(f'{encoder_salt = }')
    print(f'{encoder_key = }')

def main():
    r = conn()

    # leak(r)
    encoder = Encoder()
    test_frame = encoder.encode(0, b'pwned lmao', 200)
    print(r.decode(test_frame))

    # c1_valid = encoder.encode(0, b'pwned lmao', 69)
    # print(altered_len(packet, 0x700).hex())


if __name__ == "__main__":
    main()
