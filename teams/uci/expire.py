from Crypto.Cipher import AES
from pwn import *
from Crypto.Hash import SHA256
payload = b'\x02\x00\x00\x00QY4!e\xa4\xe2\xc9\xb5\xdf\x15d:Q\xf9\xd7o\x8f!_\xc9l\x03%\x1a0\x83C\xfcy\xb9]\xf6\xf8\xe0C\x15\xe4,4tn"U\xff\xc9d\xce\xdd<\x01\xab\xbd\x8e\xd4W\xf1\xbd\xfbxa_\x0eA2\xce\xb6K\x02a%c\xe1\x96\x81G\xa2\xc8\x9b\x91l\x8e\x0e\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
channel = u32(payload[:4])
mask_key = payload[4:20]
msg_key = payload[20:36]
data_key = payload[36:52]
sub_key = payload[52:68]
check_sum = payload[68:88]
print(f"{channel=}")
print(f"{mask_key.hex()=}")
print(f"{msg_key.hex()=}")
print(f"{data_key.hex()=}")
print(f"{sub_key.hex()=}")
print(f"{check_sum.hex()=}")

frame = {"channel": 2, "timestamp": 2054421484106043, "encoded": "020000003b71c7467c4c070040000000dd251006837410d0c89bc054427e9646f7025fd9061ea31cce37776c4162ecb845c236521d3ce9bb3095d700eef261ef7305c9d57cfd2d05f88a8d7b0c3b1224cdf614311683d107c419ea2b783bf7daf37491596e72c4ea5361d37a2f0f79cfe7169cf8b3bd7e0c8340252896189144"}
ct = frame["encoded"]
timestamp = frame["timestamp"]

frame_channel = ct[:8]
frame_time = ct[8:24]
frame_size = ct[24:32]

frame_iv = ct[32:64]

print(frame_channel, frame_time, frame_size, frame_iv)


def compute_hash(data):
    """Compute the SHA-256 hash of the data"""
    hash = SHA256.new()
    hash.update(data)
    return hash.digest()


def pad(data, block_size):
    """Pad the data to the block size"""
    assert type(data) == bytes, "Data must be bytes"
    extra = len(data) % block_size
    if extra == 0:
        padding_length = 0
    else:
        padding_length = block_size - extra
    return data + b'\x00' * padding_length


def sym_decrypt(key, iv, data):
    cipher = AES.new(key=key, iv=iv, mode=AES.MODE_CBC)
    return cipher.decrypt(data)


def xor(byte1, byte2):
    """XOR two bytes"""
    # Extend them two same length
    if len(byte1) < len(byte2):
        byte = byte1
        byte1 = byte2
        byte2 = byte
    byte2 = byte2.ljust(len(byte1), b'\x00')
    return bytes(a ^ b for a, b in zip(byte1, byte2))


c1_key = xor(
    compute_hash(xor(mask_key, timestamp.to_bytes(8, 'little'))), msg_key)
c1_key = c1_key[:16]
c1_ct = bytes.fromhex(ct[64:128])
c1 = sym_decrypt(c1_key, bytes.fromhex(frame_iv), c1_ct)
print(c1)
print(u64(c1[8:16]), timestamp)
nonce = c1[:8] + c1[16:24]

# Prepare C2 info
c2_key = xor(nonce, data_key)
c2_ct = bytes.fromhex(ct[128:])
c2 = sym_decrypt(c2_key, bytes.fromhex(frame_iv), c2_ct)
print(c2)
